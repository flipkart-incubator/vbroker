namespace com.flipkart.vbroker.entities;

enum ApiKey:byte {ProduceRequest=0, ProduceResponse=1}

// status codes

enum StatusCode:int16 {
None=0,
ProduceSuccess_NoError=101,
ProduceFailed_NoLeader=151,
ProduceFailed_NotEnoughReplicas=152,
Success=200,
ConsumeSuccess_NoError=201,
ConsumeError_DestinationDown=251,
TopicCreateFailed_AlreadyExists=351, 
TopicCreateFailed_Validation=352,
SubscriptionCreateFailed_NoTopic=451, 
SubscriptionCreateFailed_AlreadyExists=452,
SubscriptionCreateFailed_Validation=453,
QueueCreateFailed_AlreadyExists=461,
QueueCreateFailed_Validation=462,
GetLagFailed=470,
GetLagFailed_NoTopic=471,
GetLagFailed_NoSubscription=472,
GetLagFailed_NoPartition=473,
GetLagFailed_Validation=474,
Invalid_Partitions=501,
Invalid_ReplicationFactor=502,
Leader_Not_Available=503,
Controller_Not_Available=504,
Not_Leader_For_Partition=505,
Entity_Not_Exists=506
}

// common enums

enum HttpMethod:byte {POST=0, PUT=1, DELETE=2, PATCH=3}

enum TopicCategory:byte {QUEUE=0, TOPIC=1}

enum SubscriptionType:byte {STATIC=0, DYNAMIC=1}

enum SubscriptionMechanism:byte {PUSH=0, PULL=1}


// common entities

table HttpHeader {
	key:string;
	value:string;
}

table Message {
	messageId:string;
	groupId:string;
	crc:int8;
	version:int8;
	seqNo:int32;
	topicId:int16;
	partitionId:int16;
	attributes:int32;
	httpUri:string;
	httpMethod:HttpMethod;
	callbackTopicId:int16;
	callbackHttpUri:string;
	callbackHttpMethod:HttpMethod;
	headers:[HttpHeader];
	bodyLength:int32;
	bodyPayload:[int8];
}

table MessageSet {
	messages:[Message];
}

table Topic {
	id:int16;
	name:string;
	grouped:bool;
	partitions:int16;
	replicationFactor:int16;
	topicCategory:TopicCategory;
}

table FilterKeyValues {
	key:string;
	values:string;
}

table CodeRange {
	from:int16;
	to:int16;
}

table CallbackConfig {
	codeRanges:[CodeRange];
}

table Subscription {
	id:int16;
	topicId:int16;
	name:string;
	grouped:bool;
	parallelism:int16;
	requestTimeout:int16;
	subscriptionType:SubscriptionType;
	subscriptionMechanism:SubscriptionMechanism;
	httpUri:string;
	httpMethod:string;
	elastic:bool;
	filterOperator:string;
	filterKeyValuesList:[FilterKeyValues];
	callbackConfig:CallbackConfig;
}

table Queue {
	topic:Topic;
	subscription:Subscription;
}

table TopicSubscription{
	topicId:int16;
	subscriptionId:int16;
}

// request message types

union RequestMessage { ProduceRequest, FetchRequest, CreateTopicsRequest, CreateSubscriptionsRequest, CreateQueuesRequest,
 GetTopicsRequest, GetSubscriptionsRequest, GetQueuesRequest, GetLagsRequest }
	
// requests
	
table VRequest {
	version:int8;
	correlationId:int32;
	requestMessage:RequestMessage;
}

// produce request

table TopicPartitionProduceRequest {
	partitionId:int16;
	requiredAcks:int16;
	messageSet:MessageSet;
}

table TopicProduceRequest {
	topicId:int16;
	partitionRequests:[TopicPartitionProduceRequest];
}

table ProduceRequest {
	topicRequests:[TopicProduceRequest];
}

// fetch request

table TopicPartitionFetchRequest {
	partitionId:int16;
	noOfMessages:int16;
}

table TopicFetchRequest {
	subscriptionId:int16;
	topicId:int16;
	partitionRequests:[TopicPartitionFetchRequest];
}

table FetchRequest {
	topicRequests:[TopicFetchRequest];
}


// create topics request

table CreateTopicsRequest {
	topics:[Topic];
}

// create subscriptions request

table CreateSubscriptionsRequest {
	subscriptions:[Subscription];
}

// create queues request

table CreateQueuesRequest {
	queues:[Queue];
}

// get queues request

table GetQueuesRequest {
	ids:[int16];
}

// get topics request

table GetTopicsRequest {
	ids:[int16];
}

// get subscriptions request

table GetSubscriptionsRequest {
	subscriptions:[TopicSubscription];
}

// get lags request

table PartitionLagRequest {
	partitionId:int16;
}
table TopicSubscriptionLagRequest {
	subscriptionId:int16;
	topicId:int16;
	partitionLags:[PartitionLagRequest];
}

table GetLagsRequest{
	subscriptionLags:[TopicSubscriptionLagRequest];
}

root_type VRequest;


// responses

table VStatus {
	statusCode:StatusCode;
	message:string;
}

// response message types

union ResponseMessage { ProduceResponse, FetchResponse, CreateTopicsResponse, CreateSubscriptionsResponse, CreateQueuesResponse,
 GetTopicsResponse, GetQueuesResponse, GetSubscriptionsResponse, GetLagsResponse }

table VResponse {
	correlationId:int32;
	responseMessage:ResponseMessage;
}

//ProduceResponse

table TopicPartitionProduceResponse {
	partitionId:int16;
	status:VStatus;
}

table TopicProduceResponse {
	topicId:int16;
	partitionResponses:[TopicPartitionProduceResponse];
}

table ProduceResponse {
	topicResponses:[TopicProduceResponse];
}

//FetchResponse

table TopicPartitionFetchResponse {
	partitionId:int16;
	status:VStatus;
	messageSet:MessageSet;
}

table TopicFetchResponse {
	subscriptionId:int16;
	topicId:int16;
	partitionResponses:[TopicPartitionFetchResponse];
}

table FetchResponse {
	topicResponses:[TopicFetchResponse];
}

// create topics response

table CreateTopicResponse {
	id:int16;
	name:string;
	status:VStatus;
}

table CreateTopicsResponse {
	createTopicsResponse:[CreateTopicResponse];	
}

// subscription create response

table CreateSubscriptionResponse{
	id:int16;
	topicId:int16;
	name:string;
	status:VStatus;
}

table CreateSubscriptionsResponse {
	createSubscriptionResponse:[CreateSubscriptionResponse];
}

// create queues response

table CreateQueueResponse {
	id:int16;
	topicId:int16;
	subscriptionId:int16;
	status:VStatus;
}

table CreateQueuesResponse {
	createQueueResponse:[CreateQueueResponse];
}

// get topics response

table GetTopicResponse {
	topic:Topic;
	status:VStatus;
}

table GetTopicsResponse {
	topics:[GetTopicResponse];	
}

// get subscriptions response

table GetSubscriptionResponse {
	subscription:Subscription;
	status:VStatus;
}
table GetSubscriptionsResponse {
	subscriptions:[GetSubscriptionResponse];	
}

// get queues response

table GetQueueResponse {
	queue:Queue;
	status:VStatus;
}

table GetQueuesResponse {
	queues:[GetQueueResponse];
}

// get lags response

table PartitionLag {
	partitionId:int16;
	lag:int32;
	status:VStatus;
}

table SubscriptionLag {
	subscriptionId:int16;
	topicId:int16;
	partitionLags:[PartitionLag];
}

table GetLagsResponse {
	subscriptionLags:[SubscriptionLag];
}

root_type VResponse;
